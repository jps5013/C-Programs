#include <stdio.h>
#include <cs50.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

char ASCIItoOffset(char c);
char OffsettoASCII(char x, char forCase);


int main(int argc, string argv[])
{    
    if(argc != 2)
    {
        printf("You've been a very bad boy!\n");
        return 1;
    }
    // not 2 arguments accounted for
    string key = (argv[1]);
    
    for(int j = 0, n = strlen(key); j < n ;j++)
    {
        if(!isalpha(key[j]))
        {
            printf("You've been a very bad boy!\n");
            return 1;
        }
    }    
    // non alpha chars in key accounted for
    
    //now set variables needed in program.   
    string plaintext = GetString();
    int klen = strlen(key);
    /**not sure if i really need plen, I think i can just use strlen(plaintext)
     *
     */ as I only need this value within my if isalpha branch. 
    int plen = strlen(plaintext);
   
    /**
     * what I want to do is implement keyindex = jth char % klen and use that as the key index
     * within the is alpha block. this will ensure the key only incrments for alpha chars
     * say key is boo, klen = 3. we are at k[0] 0% 3 = 0 so we encipher with k[0]
     * k[2] = 2 % 3 so k[2] will print
     * 
     * so  0 % 5 prints k[0] 
     *if klen = 5, keyindex[5] will be the key[0] so in effect wrapping around  
     *
     *
     */
  
     for(int i = 0; i < plen ;i++)
     {
        if(isalpha(plaintext[i]))
        { 
            // encipher algorithm = c[j] = (p[i] + k[j]) % 26
            // set p[i] to 0 using ASCIItoOffset Funtion and store in offset.
            char offset = ASCIItoOffset(plaintext[i]);
            // i % klen will ensure j wraps around
            /* say klen = 3 and plen = 10
             * k[ 0 % 3] = k[0], k[1%3] = k[1], k[2 % 3] = k[2] k[3 % 3] = k[0]
             * k[4 % 3] = k[1] so wrap around key works successfully.
             * so to me k[j] should be the k[ith char of plaintext % klen]
             */
             // replave value of offset with offset + k[j]
             // so no we have c[j] = (p[i] + k[j])
            offset += key[i % klen];
            // now we have c[j] = (p[i] + k[j])% 26
            offset %= 26;
            // now we take that value and convert it back to ASCII for printing.
            char cipher = OffsettoASCII(offset, plaintext[i]);
            printf("%c", cipher);          
        }               
        else                
        {
            printf("%c",plaintext[i]);
        } 
     }
    printf("\n");
    return 0;       
}



char ASCIItoOffset(char c)
{
    int offset;
    if(islower(c))
    {
        offset = c - 'a';
    }
    else
    {
        offset = c - 'A';   
    }
    return offset;
}

char OffsettoASCII(char x, char forCase)
{   
    int reset; 
    if(islower(forCase))
    {
        reset = x + 'a'; 
    }
    else
    {
        reset = x + 'A';   
    }
    return reset;
}
